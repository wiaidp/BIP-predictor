# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
scale_vec<-1:10*0.1
c_vec<-NULL
for (i in 1:length(scale_vec))#i<-1
{
print(i)
scale<-scale_vec[i]
c<-2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c_vec<-c(c_vec,c)
}
ts.plot(c_vec)
# Select a scale
scale<-0.5
# Select closet value in scale_vec
select<-which(abs(scale_vec-scale)==min(abs(scale_vec-scale)))
# Retrieve corresponding optimal c
c<-c_vec[select]
# Compute timeliness term and compare with other linearized designs
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Recompute other linearized timeliness terms (based on scale)
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
rm(list=ls())
# AR(1) Filter
a1<-0.9
L<-100
b<-a1^(0:(L-1))
# Normalize
b<-b/sum(b)
ts.plot(b)
# Computes amplitude and time shifts (mainly for illustration purposes)
amp_shift_func<-function(K,b,plot_T)
{
#  if (sum(b)<0)
#  {
#    print("Sign of coefficients has been changed")
#    b<-b*sign(sum(b))
#  }
omega_k<-(0:K)*pi/K
trffkt<-0:K
for (i in 0:K)
{
trffkt[i+1]<-b%*%exp(1.i*omega_k[i+1]*(0:(length(b)-1)))
}
amp<-abs(trffkt)
shift<-Arg(trffkt)/omega_k
shift[1]<-sum((0:(length(b)-1))*b)/sum(b)
if (plot_T)
{
par(mfrow=c(2,1))
plot(amp,type="l",axes=F,xlab="Frequency",ylab="Amplitude",main="Amplitude")
axis(1,at=1+0:6*K/6,labels=c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi"))
axis(2)
box()
plot(shift,type="l",axes=F,xlab="Frequency",ylab="Shift",main="Shift",ylim=c(min(min(shift,na.rm=T),0),max(shift,na.rm=T)))
axis(1,at=1+0:6*K/6,labels=c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi"))
axis(2)
box()
}
return(list(trffkt=trffkt,amp=amp,shift=shift))
}
K<-600
plot_T<-T
amp_shift_obj<-amp_shift_func(K,b,plot_T)
trffkt<-amp_shift_obj$trffkt
amp<-amp_shift_obj$amp
shift<-amp_shift_obj$shift
phase<-shift*pi*(0:(K))/(K)
ts.plot(cbind(amp,phase))
# Ideal trend filter
cutoff<-pi/6
A<-(0:K)<(cutoff/pi)*K
Phi<-rep(0,K+1)
# Amplitude, phase of scaled AR(1)
scale<-0.2
A_hat<-scale*amp
Phi_hat<-phase
# Original Timeliness term (not a quadratic function of filter)
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
# Current I-DFA Approximation: squared imaginary part of Psi_hat
# Error sources: A is replaced by A_hat and angle is twice as large
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
# Better approximation (based on corrected version of I-MDFA)
# Angle is twice as large but A_hat is now correct
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
# Next we try to address the angle
# Weights
if (0.<scale&scale<=0.1)
c1_0<-0.75
if (0.1<scale&scale<=0.2)
c1_0<-1.5
if (0.2<scale&scale<=0.4)
c1_0<-1.75
if (0.4<scale&scale<=0.8)
c1_0<-2.37
c1_0<-3*sqrt(scale)
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Better approximation (based on corrected version of I-MDFA)
T_new<-A_new*A*sin((Phi-Phi_new))^2
# Plot
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colo<-rainbow(ncol(mplot))
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
#--------------------------------------------------
# Optimization
calibration_func<-function(c)
{
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
T_new<-A_new*A*sin((Phi-Phi_new))^2
#  T_new<-A_new^2*sin((Phi-Phi_new))^2
return(mean((abs(T_cust-T_new)[A])^2))
}
if (F)
{
c<-2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
T_new<-A_new*A*sin((Phi-Phi_new))^2
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
}
#----------------------------------------
# Optimize vor various values of scale
scale_vec<-1:10*0.1
c_vec<-NULL
for (i in 1:length(scale_vec))#i<-1
{
print(i)
scale<-scale_vec[i]
c<-2
# Recompute reference (original) Timeliness based on scale
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c_vec<-c(c_vec,c)
}
ts.plot(c_vec)
# Select a scale
scale<-0.5
# Select closet value in scale_vec
select<-which(abs(scale_vec-scale)==min(abs(scale_vec-scale)))
# Retrieve corresponding optimal c
c<-c_vec[select]
# Compute timeliness term and compare with other linearized designs
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Recompute other linearized timeliness terms (based on scale)
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
rm(list=ls())
path.main<-getwd()
path.out<-paste(path.main,"/Latex/",sep="")
path.sweave<-paste(path.main,"/Sweave/",sep="")
#------------------------------
paper<-"BIP_predictor"
script <- paste(path.sweave,paper,sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
## create a LaTeX file
Sweave(script,output=paste(path.out,paper,".tex",sep=""))
#Stangle(script)
x_mat
rm(list=ls())
path.main<-getwd()
path.out<-paste(path.main,"/Latex/",sep="")
path.sweave<-paste(path.main,"/Sweave/",sep="")
#------------------------------
paper<-"BIP_predictor"
script <- paste(path.sweave,paper,sep="")
## enforce par(ask=FALSE)
options(device.ask.default=FALSE)
## create a LaTeX file
Sweave(script,output=paste(path.out,paper,".tex",sep=""))
#Stangle(script)
hp_c
hp_two
filter(x_mat_wc[,1],hp_two,side=2)
x_mat_wc
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
colnames(mplot)<-c("GDP: HP two-sided","HP one-sided")
colo<-c("black","red")
main_title<-paste("GDP shifted  by ",h," quarters",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
if (h==0)
legend("bottomleft", legend = colnames(mplot), col = colo, lty = 1, lwd = 1, bty = "n")
box()
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
colnames(mplot)<-c("GDP: HP two-sided","HP one-sided")
colo<-c("black","red")
main_title<-paste("GDP shifted  by ",h," quarters",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
if (h==0)
legend("bottomleft", legend = colnames(mplot), col = colo, lty = 1, lwd = 1, bty = "n")
box()
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownmaes(mplot)<-rownames(x_mat_wc)
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
colnames(mplot)<-c("GDP: HP two-sided","HP one-sided")
colo<-c("black","red")
main_title<-paste("GDP shifted  by ",h," quarters",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
if (h==0)
legend("bottomleft", legend = colnames(mplot), col = colo, lty = 1, lwd = 1, bty = "n")
box()
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))[lenth(hp_c):nrow(x_mat_wc)]
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))[length(hp_c):nrow(x_mat_wc)]
rownames(mplot)<-rownames(x_mat_wc)
length(hp_c)
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))[length(hp_c):nrow(x_mat_wc),]
rownames(mplot)<-rownames(x_mat_wc)
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
mplot<-mplot[[length(hp_c):nrow(mplot),]
rownames(mplot)<-rownames(x_mat_wc)
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
mplot<-mplot[length(hp_c):nrow(mplot),]
rownames(mplot)<-rownames(x_mat_wc)
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
length(hp_c):nrow(mplot)
mplot[length(hp_c):nrow(mplot),]
k<-1
mplot<-cbind(filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-mplot[length(hp_c):nrow(mplot),]
colnames(mplot)<-c("GDP: HP two-sided","HP one-sided")
colo<-c("black","red")
main_title<-paste("GDP shifted  by ",h," quarters",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
if (h==0)
legend("bottomleft", legend = colnames(mplot), col = colo, lty = 1, lwd = 1, bty = "n")
box()
k<-1
mplot<-cbind(x_mat_wc[,k],filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-mplot[length(hp_c):nrow(mplot),]
colnames(mplot)<-c("GDP: HP two-sided","HP one-sided")
k<-1
mplot<-cbind(x_mat_wc[,k],filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-mplot[length(hp_c):nrow(mplot),]
colnames(mplot)<-c("GDP","GDP: HP two-sided","HP one-sided")
colo<-c("black","blue","red")
main_title<-paste("GDP shifted  by ",h," quarters",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
if (h==0)
legend("bottomleft", legend = colnames(mplot), col = colo, lty = 1, lwd = 1, bty = "n")
box()
k<-1
mplot<-cbind(x_mat_wc[,k],filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-mplot[length(hp_c):nrow(mplot),]
colnames(mplot)<-c("GDP","GDP: HP two-sided","HP one-sided")
colo<-c("black","blue","red")
main_title<-"GDP: original, HP two-sided, one-sided"
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
mplot<-cbind(x_mat_wc[,k],filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-mplot[length(hp_c):nrow(mplot),]
colnames(mplot)<-c("GDP","GDP: HP two-sided","HP one-sided")
colo<-c("black","blue","red")
main_title<-"GDP (black), HP two-sided (blue), one-sided (red)"
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
k<-1
mplot<-cbind(x_mat_wc[,k],filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-na.exclude(mplot)
colnames(mplot)<-c("GDP","GDP: HP two-sided","HP one-sided")
colo<-c("black","blue","red")
main_title<-"GDP (black), HP two-sided (blue), one-sided (red)"
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
file = "./Figures/GDP_HP_one_two.pdf"
pdf(file = paste(path.out,file,sep=""), paper = "special", width = 7.5, height = 6)
k<-1
mplot<-cbind(x_mat_wc[,k],filter(x_mat_wc[,k],hp_two,side=2),filter(x_mat_wc[,k],hp_c,side=1))
rownames(mplot)<-rownames(x_mat_wc)
mplot<-na.exclude(mplot)
#mplot<-mplot[length(hp_c):nrow(mplot),]
colnames(mplot)<-c("GDP","GDP: HP two-sided","HP one-sided")
colo<-c("black","blue","red")
main_title<-"GDP (black), HP two-sided (blue), one-sided (red)"
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
for (i in 1:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
dev.off()
