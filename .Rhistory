# Recompute other linearized timeliness terms (based on scale)
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
rm(list=ls())
# AR(1) Filter
a1<-0.9
L<-100
b<-a1^(0:(L-1))
# Normalize
b<-b/sum(b)
ts.plot(b)
# Computes amplitude and time shifts (mainly for illustration purposes)
amp_shift_func<-function(K,b,plot_T)
{
#  if (sum(b)<0)
#  {
#    print("Sign of coefficients has been changed")
#    b<-b*sign(sum(b))
#  }
omega_k<-(0:K)*pi/K
trffkt<-0:K
for (i in 0:K)
{
trffkt[i+1]<-b%*%exp(1.i*omega_k[i+1]*(0:(length(b)-1)))
}
amp<-abs(trffkt)
shift<-Arg(trffkt)/omega_k
shift[1]<-sum((0:(length(b)-1))*b)/sum(b)
if (plot_T)
{
par(mfrow=c(2,1))
plot(amp,type="l",axes=F,xlab="Frequency",ylab="Amplitude",main="Amplitude")
axis(1,at=1+0:6*K/6,labels=c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi"))
axis(2)
box()
plot(shift,type="l",axes=F,xlab="Frequency",ylab="Shift",main="Shift",ylim=c(min(min(shift,na.rm=T),0),max(shift,na.rm=T)))
axis(1,at=1+0:6*K/6,labels=c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi"))
axis(2)
box()
}
return(list(trffkt=trffkt,amp=amp,shift=shift))
}
K<-600
plot_T<-T
amp_shift_obj<-amp_shift_func(K,b,plot_T)
trffkt<-amp_shift_obj$trffkt
amp<-amp_shift_obj$amp
shift<-amp_shift_obj$shift
phase<-shift*pi*(0:(K))/(K)
ts.plot(cbind(amp,phase))
# Ideal trend filter
cutoff<-pi/6
A<-(0:K)<(cutoff/pi)*K
Phi<-rep(0,K+1)
# Amplitude, phase of scaled AR(1)
scale<-0.2
A_hat<-scale*amp
Phi_hat<-phase
# Original Timeliness term (not a quadratic function of filter)
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
# Current I-DFA Approximation: squared imaginary part of Psi_hat
# Error sources: A is replaced by A_hat and angle is twice as large
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
# Better approximation (based on corrected version of I-MDFA)
# Angle is twice as large but A_hat is now correct
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
# Next we try to address the angle
# Weights
if (0.<scale&scale<=0.1)
c1_0<-0.75
if (0.1<scale&scale<=0.2)
c1_0<-1.5
if (0.2<scale&scale<=0.4)
c1_0<-1.75
if (0.4<scale&scale<=0.8)
c1_0<-2.37
c1_0<-3*sqrt(scale)
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Better approximation (based on corrected version of I-MDFA)
T_new<-A_new*A*sin((Phi-Phi_new))^2
# Plot
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colo<-rainbow(ncol(mplot))
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
#--------------------------------------------------
# Optimization
calibration_func<-function(c)
{
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
T_new<-A_new*A*sin((Phi-Phi_new))^2
#  T_new<-A_new^2*sin((Phi-Phi_new))^2
return(mean((abs(T_cust-T_new)[A])^2))
}
if (F)
{
c<-2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
T_new<-A_new*A*sin((Phi-Phi_new))^2
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
}
#----------------------------------------
# Optimize vor various values of scale
scale_vec<-1:10*0.1
c_vec<-NULL
for (i in 1:length(scale_vec))#i<-1
{
print(i)
scale<-scale_vec[i]
c<-2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c_vec<-c(c_vec,c)
}
ts.plot(c_vec)
# Select a scale
scale<-0.5
# Select closet value in scale_vec
select<-which(abs(scale_vec-scale)==min(abs(scale_vec-scale)))
# Retrieve corresponding optimal c
c<-c_vec[select]
# Compute timeliness term and compare with other linearized designs
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Recompute other linearized timeliness terms (based on scale)
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
scale_vec<-1:10*0.1
c_vec<-NULL
for (i in 1:length(scale_vec))#i<-1
{
print(i)
scale<-scale_vec[i]
c<-2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c_vec<-c(c_vec,c)
}
ts.plot(c_vec)
# Select a scale
scale<-0.5
# Select closet value in scale_vec
select<-which(abs(scale_vec-scale)==min(abs(scale_vec-scale)))
# Retrieve corresponding optimal c
c<-c_vec[select]
# Compute timeliness term and compare with other linearized designs
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Recompute other linearized timeliness terms (based on scale)
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
rm(list=ls())
# AR(1) Filter
a1<-0.9
L<-100
b<-a1^(0:(L-1))
# Normalize
b<-b/sum(b)
ts.plot(b)
# Computes amplitude and time shifts (mainly for illustration purposes)
amp_shift_func<-function(K,b,plot_T)
{
#  if (sum(b)<0)
#  {
#    print("Sign of coefficients has been changed")
#    b<-b*sign(sum(b))
#  }
omega_k<-(0:K)*pi/K
trffkt<-0:K
for (i in 0:K)
{
trffkt[i+1]<-b%*%exp(1.i*omega_k[i+1]*(0:(length(b)-1)))
}
amp<-abs(trffkt)
shift<-Arg(trffkt)/omega_k
shift[1]<-sum((0:(length(b)-1))*b)/sum(b)
if (plot_T)
{
par(mfrow=c(2,1))
plot(amp,type="l",axes=F,xlab="Frequency",ylab="Amplitude",main="Amplitude")
axis(1,at=1+0:6*K/6,labels=c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi"))
axis(2)
box()
plot(shift,type="l",axes=F,xlab="Frequency",ylab="Shift",main="Shift",ylim=c(min(min(shift,na.rm=T),0),max(shift,na.rm=T)))
axis(1,at=1+0:6*K/6,labels=c("0","pi/6","2pi/6","3pi/6","4pi/6","5pi/6","pi"))
axis(2)
box()
}
return(list(trffkt=trffkt,amp=amp,shift=shift))
}
K<-600
plot_T<-T
amp_shift_obj<-amp_shift_func(K,b,plot_T)
trffkt<-amp_shift_obj$trffkt
amp<-amp_shift_obj$amp
shift<-amp_shift_obj$shift
phase<-shift*pi*(0:(K))/(K)
ts.plot(cbind(amp,phase))
# Ideal trend filter
cutoff<-pi/6
A<-(0:K)<(cutoff/pi)*K
Phi<-rep(0,K+1)
# Amplitude, phase of scaled AR(1)
scale<-0.2
A_hat<-scale*amp
Phi_hat<-phase
# Original Timeliness term (not a quadratic function of filter)
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
# Current I-DFA Approximation: squared imaginary part of Psi_hat
# Error sources: A is replaced by A_hat and angle is twice as large
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
# Better approximation (based on corrected version of I-MDFA)
# Angle is twice as large but A_hat is now correct
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
# Next we try to address the angle
# Weights
if (0.<scale&scale<=0.1)
c1_0<-0.75
if (0.1<scale&scale<=0.2)
c1_0<-1.5
if (0.2<scale&scale<=0.4)
c1_0<-1.75
if (0.4<scale&scale<=0.8)
c1_0<-2.37
c1_0<-3*sqrt(scale)
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Better approximation (based on corrected version of I-MDFA)
T_new<-A_new*A*sin((Phi-Phi_new))^2
# Plot
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colo<-rainbow(ncol(mplot))
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
#--------------------------------------------------
# Optimization
calibration_func<-function(c)
{
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
T_new<-A_new*A*sin((Phi-Phi_new))^2
#  T_new<-A_new^2*sin((Phi-Phi_new))^2
return(mean((abs(T_cust-T_new)[A])^2))
}
if (F)
{
c<-2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
T_new<-A_new*A*sin((Phi-Phi_new))^2
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
}
#----------------------------------------
# Optimize vor various values of scale
scale_vec<-1:10*0.1
c_vec<-NULL
for (i in 1:length(scale_vec))#i<-1
{
print(i)
scale<-scale_vec[i]
c<-2
# Recompute reference (original) Timeliness based on scale
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
opt_obj<-optim(c,calibration_func)
c<-opt_obj$par
c_vec<-c(c_vec,c)
}
ts.plot(c_vec)
# Select a scale
scale<-0.5
# Select closet value in scale_vec
select<-which(abs(scale_vec-scale)==min(abs(scale_vec-scale)))
# Retrieve corresponding optimal c
c<-c_vec[select]
# Compute timeliness term and compare with other linearized designs
c1_0<-c
c2_0<-1
# Normalize
c1<-c1_0/(c1_0+c2_0)
c2<-c2_0/(c1_0+c2_0)
# Define new trffkt: linear combination of original trffkt and complex conjugate trffkt (linear in filter parameters)
trffkt_new<-c1*trffkt+c2*Conj(trffkt)
A_new<-scale*abs(trffkt_new)
Phi_new<-Arg(trffkt_new)
# Recompute other linearized timeliness terms (based on scale)
A_hat<-scale*amp
# Timeliness terms
T_cust<-A*A_hat*sin((Phi-Phi_hat)/2)^2
T_idfa<-A_hat^2*sin((Phi-Phi_hat))^2
T_better<-A_hat*A*sin((Phi-Phi_hat))^2
T_new<-A_new*A*sin((Phi-Phi_new))^2
#T_new<-A_new^2*sin((Phi-Phi_new))^2
# Absolute errors in pass band
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
mplot<-cbind(abs(T_cust-T_idfa),abs(T_cust-T_better),abs(T_cust-T_new))[A,]
colnames(mplot)<-c("I-DFA","Corrected for amplitude","Linear combination")
plot(mplot[,1],type="l",axes=F,xlab="Frequency",ylab="",main=paste("Timeliness approximation error: Cutoff=pi/",pi/cutoff,", Shrinkage=",scale,sep=""),ylim=c(min(mplot),max(mplot)),col=colo[1])
if (ncol(mplot)>1)
{
lines(mplot[,2],col=colo[2])
mtext(colnames(mplot)[1],line=-1,col=colo[1])
for (i in 2:ncol(mplot))
{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*nrow(mplot)/4,labels=c("0",paste("pi/",(K/(0:4*nrow(mplot)/4))[2:5],sep="")))
axis(2)
box()
